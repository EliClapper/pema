---
title: "pema application"
author: "Sara van Erp"
date: "3/30/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Packages
First, load in the necessary packages. In addition, if you are running the model locally on a multicore machine, you can set `options(mc.cores = 4)`. This ensures the different MCMC chains will be run in parallel, making estimation faster.

```{r}
library(pema)
options(mc.cores = 4)
library(tidyverse)
library(fastDummies)
```


## Data

In this application, we will work with the bonapersona data (Bonapersona et al., 2019). The data and codebook can be found [here](https://zenodo.org/record/2540657#.XEGPP2ko9aR). First, we read in the data and make sure all relevant variables are of the correct type. 

Q1 Caspar: de data lijkt nog niet beschikbaar in de laatste versie van het package?

```{r data}
bonapersona <- read.csv2("./pema_application/MAB_data.csv")
summary(bonapersona)
bonapersona$yi <- as.numeric(bonapersona$yi)
bonapersona$vi <- as.numeric(bonapersona$vi)
bonapersona$bias <- as.numeric(bonapersona$bias)
```
For this application, we use the same 26 moderators as in Bonapersona et al. (2019; see Figure 3A for an overview). We select these moderators and create dummy variables for all categorical moderators.

```{r dummies}
datsel <- bonapersona %>% 
  select(yi, vi, author, mTimeLength, year, model, ageWeek, testAuthorGrouped,
         strainGrouped, bias, species, domain, mLDGrouped, waterTcate, 
         origin, mCageGrouped, seqGeneration, baseline, blindExp,
         retentionGrouped, hit2Grouped, outBlind, sex, housing,
         testLDGrouped, freezingType, blindRand, control, mControlGrouped) 

# Recode categorical moderators
catmod <- c("model", "testAuthorGrouped", "strainGrouped", "species", "domain", "mLDGrouped", "waterTcate", "origin", 
            "mCageGrouped", "seqGeneration", "baseline", "blindExp", "retentionGrouped", "hit2Grouped",
            "outBlind", "sex", "housing", "testLDGrouped", "freezingType", "blindRand", "control", "mControlGrouped")
datdum <- dummy_cols(datsel, 
                     select_columns = catmod,
                     remove_first_dummy = TRUE,
                     remove_selected_columns = TRUE) 
```

## Two-level model
First, for simplicity, we run a two-level model ignoring the fact that certain effect sizes come from the same study.

```{r}
dat2l <- datdum %>%
  select(-author)
```


### Two-level model with the lasso prior
We start with running a penalized meta-analysis using the lasso prior. Compared to the horseshoe prior, the lasso is easier to use because it has only two hyperparameters to set. However, the lighter tails of the lasso can result in large coefficients being shrunken too much towards zero thereby leading to potentially more bias compared to the regularized horseshoe prior. 

For the lasso prior, we need to specify the degrees of freedom `df` and the `scale`. Both default to 1. The degrees of freedom determines the chi-square prior that is specified for the inverse-tuning parameter. Increasing the degrees of freedom will allow larger values for the inverse-tuning parameter, leading to less shrinkage. Increasing the scale parameter will also result in less shrinkage. The influence of these hyperparameters can be visualized through the implemented shiny app, which can be called via `shiny_prior()`.

Q2 Caspar: `standardize = TRUE` resulteert in NAs waardoor Stan een error geeft. Weet jij hoe dit kan? Daarnaast moeten we misschien een meer informatieve waarschuwing geven in het algemeen als er NAs in de data zitten?

```{r}
# Manually standardize the continuous moderators, because `standardize = TRUE` does not work for some reason
dat2l <- dat2l %>%
  mutate(year = scale(year)) %>%
  mutate(ageWeek = scale(ageWeek)) %>%
  mutate(bias = scale(bias))
```

```{r lasso, cache = TRUE}
fit.lasso <- brma(yi ~ .,
            data = dat2l,
            vi = "vi",
            method = "lasso",
            standardize = FALSE,
            prior = c(df = 1, scale = 1),
            mute_stan = FALSE)
```

#### Assessing convergence and interpreting the results
We can request the results using the `summary` function. Before we interpret the results, we need to ensure that the MCMC chains have converged to the posterior distribution. Two helpful diagnostics provided in the summary are the number of effective posterior samples `n_eff` and the potential scale reduction factor `Rhat`. `n_eff` is an estimate of the number of independent samples from the posterior. Ideally, the ratio `n_eff` to total samples is as close to 1 as possible. `Rhat` compares the between- and within-chain estimates and is ideally close to 1 (indicating the chains have mixed well). Should any values for `n_eff` or `Rhat` be far from these ideal values, you can try increasing the number of iterations through the `iter` argument. By default, the `brma` function runs four MCMC chains with 2000 iterations each, half of which is discarded as burn-in. As a result, a total of 4000 iterations is available on which posterior summaries are based. If this does not help, non-convergence might indicate a problem with the model specification.

```{r}
options(max.print = 10000)
summary(fit.lasso)
```

If we are satisfied with the convergence, we can continue looking at the posterior summary statistics. The `summary` function provides the posterior mean estimate for the effect of each moderator. Since Bayesian penalization does not automatically shrink estimates exactly to zero, some additional criterion is needed to determine which moderators should be selected in the model. Currently, this is done using the 95% credible intervals, with a moderator being selected if zero is excluded in this interval. In the `summary` this is denoted by an asterisk for that moderator. In this model, the only significant moderator is the dummy variable for sex. All other coefficients are not significant after being shrunken towards zero by the lasso prior.

Q3 Caspar: Deze resultaten lijken niet overeen te komen met die uit het originele paper waar metaforest is gebruikt. Daar lijkt sex namelijk niet zo'n belangrijke moderator (gebaseerd op figuur 3A). Ik weet alleen niet genoeg van metaforest om te bepalen of dit problematisch is of logisch te verklaren door de onderliggende methode.

### Two-level model with the horseshoe prior
Next, we look into the regularized horseshoe prior. The horseshoe prior has five hyperparameters that can be set. Three parameters are degrees of freedom parameters which influence the tails of the distributions in the prior. Generally, it is not needed to specify different values for these hyperparameters. Here, we focus instead on the global scale parameter and the scale of the slab.

```{r hs, cache = TRUE}
# use the default settings
fit.hs1 <- brma(yi ~ .,
               data = dat2l,
               vi = "vi",
               method = "hs",
               standardize = FALSE,
               prior = c(df = 1, df_global = 1, df_slab = 4, scale_global = 1, scale_slab = 1, relevant_pars = NULL),
               mute_stan = FALSE)

# reduce the global scale
fit.hs2 <- brma(yi ~ .,
                data = dat2l,
                vi = "vi",
                method = "hs",
                standardize = FALSE,
                prior = c(df = 1, df_global = 1, df_slab = 4, scale_global = 0.1, scale_slab = 1, relevant_pars = NULL),
                mute_stan = FALSE)

# increase the scale of the slab
fit.hs3 <- brma(yi ~ .,
                data = dat2l,
                vi = "vi",
                method = "hs",
                standardize = FALSE,
                prior = c(df = 1, df_global = 1, df_slab = 4, scale_global = 1, scale_slab = 5, relevant_pars = NULL),
                mute_stan = FALSE)

```

Note that the horseshoe prior results in some divergent transitions. This can be an indication of non-convergence. However, these divergences arise often when using the horseshoe prior and as long as there are not too many of them, the results can still be used.

Next, we plot the posterior mean estimates for a selection of moderators for the different priors. 

```{r}
df.fun <- function(fit, prior){
  plotdat <- data.frame(fit$coefficients)
  plotdat$par <- rownames(plotdat)
  plotdat$Prior <- prior
  return(plotdat)
}

df0 <- df.fun(fit.lasso, prior = "lasso")
df1 <- df.fun(fit.hs1, prior = "hs default")
df2 <- df.fun(fit.hs2, prior = "hs reduced global scale")
df3 <- df.fun(fit.hs3, prior = "hs increased slab scale")

df <- rbind.data.frame(df0, df1, df2, df3)

# select pars with highest posterior mean estimates 
parsel <- df1 %>%
  arrange(desc(abs(`mean`))) %>%
  select(par) %>%
  filter(!par == "tau2")

dfsub <- df %>%
  filter(par %in% parsel$par[1:10] )

pd <- 0.5

ggplot(dfsub, aes(x=mean, y=par, group = Prior)) + 
  geom_errorbar(aes(xmin=X2.5., xmax=X97.5., colour = Prior), width=.1, position = position_dodge(width = pd)) +
  geom_point(aes(colour = Prior), position = position_dodge(width = pd)) +
  theme_bw() + xlab("Posterior mean") + ylab("")
```

We can see that, in general, the different priors give quite similar results in this application. A notable exception is the estimate for the dummy variable `testAuthorGrouped_stepDownAvoidance` which is much smaller for the lasso compared to the horseshoe specification. This indicates that the lasso can shrink large coefficients more towards zero whereas the horseshoe is better at keeping them large.

## Three-level model
Finally, we can also take into account the fact that some effect sizes might come from the same study by fitting a three-level model as follows:

```{r 3level, cache = TRUE}
fit.3l <- brma(yi ~ .,
               data = datdum,
               vi = "vi",
               study = "author",
               method = "lasso",
               standardize = FALSE,
               prior = c(df = 1, scale = 1),
               mute_stan = FALSE)
```



